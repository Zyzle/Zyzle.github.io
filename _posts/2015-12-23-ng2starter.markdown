---
layout: post
title:  "Super Simple Angular 2 Starter Project"
date:   2015-12-23 13:46:00
author: "Zyzle"
img: "drafts/angular-momentum.png"
img_link: "https://commons.wikimedia.org/wiki/File:Angular_momentum_definition.svg"
img_license: ["pd"]
tags: ["tools", "Angular 2", "TypeScript", "Webpack", "Gulp"]
comments: true
---

Angular 2 is the latest edition of Google's JavaScript web framework. Rather than being a simple update to the existing framework this is a _start again with lessons learned_ project that aims to solve the issues of the existing Angular 1.x and provide a whole host of new features for the modern web. Now that the first beta version of Angular 2 has been released this seems like the perfect time to look at a getting started guide.

## Simple Starter

The starter project I'm going to go over here is one I've adapted from various sources found while experimenting with the framework through the alpha releases. In this post I'm going to go over the tools used in it, how it differs from other starter projects out there, and why.

First up the code for the project can be found in my Github repository [Zyzle/ng2starter](https://github.com/Zyzle/ng2starter). I wont be going too deeply into Angular 2 as a framework other than th basics of whats going on in the starter app, if you're looking for more of a getting started guide I suggest the one on [angular.io](https://angular.io/docs/ts/latest/tutorial/)

### TypeScript

Angular 2 is written in [TypeScript](http://www.typescriptlang.org/). TypeScript is being developed by Microsoft as their next generation web language and is a superset of JavaScript, incorporating ECMAScript6 features such as: fat-arrow functions, default parameters, classes, and modules, plus on top of them adds static typing which allows for compile-time type checking.

While Github shows my project language breakdown as largely JavaScript, this is entirely due to the tool configuration files. Personally I would choose TypeScript over the other JavaScript variants for writing Angular 2 apps even though Angular 2 supports writing apps in ES6 and ES5 (the other option for developing in Angular 2 is of course the [Dart](https://www.dartlang.org/) language).

### The Project

I'm lets take a look at the code then. The app itself is made up of only 4 files, the `index.html` and those in the `app` directory, everything else in the repository is configuration):

{: .highlight }
```
ng2starter/
  ├── index.html
  ├── app/
  |   ├── bootstrap.ts
  |   ├── hello.html
  |   └── hello.ts
  ├── gulpfile.js
  ├── package.json
  ├── tsconfig.json
  ├── tslint.json
  └── webpack.config.js
```

`index.html`, as you might have guessed, is the main application page. This is some simple HTML containing the Angular 2 app main tag and the `script` tags to load the required polyfills/shims and the Angular 2 app itself.

{% highlight html %}
<!doctype html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Angular2 playground</title>

    <script src="lib/angular2-polyfills.js"></script>
    <script src="lib/es6-shim.js"></script>
    <script src="lib/bundle.js"></script>
</head>

<body>
    <hello-app>Loading...</hello-app>
</body>

</html>
{% endhighlight %}

`angular2-polyfills.js` is provided by the npm package for Angular 2 and contains `reflect-metadata` and `zone.js` both are required for Angular 2 to run and must be loaded before anything else in the app. `bundle.js` is the build application bundle created by Webpack containing the Angular 2 app and it's dependencies.

You may have noticed the custom `<hello-app>` tag. Angular 2 apps are built around web components, this tag is the root component we will define as our applications top level.

`es6-shim.js` is only strictly necessary if you need to support browsers that don't implement parts of the ES6 specification, however this includes IE <= 11 which still hold a relatively large share of the browser usage world wide (the numbers on this are inherently difficult to measure and the two most often quoted sources, StatCounter and Net Market Share give wildly different results), in my opinion its worth the few extra Kb.

Now lets take a look at `bootstrap.ts`.

{% highlight ts %}
import {bootstrap} from 'angular2/bootstrap';

import {HelloApp} from './hello';

bootstrap(HelloApp);
{% endhighlight %}

Those three lines are all we need to bootstrap our Angular 2 app. The `bootstrap` method tells Angular 2 that our root component is going to be the `HelloApp` component we are importing from the `hello.ts` file in the line above. In reality there's no need to have this `bootstrap` function in its own file. It could just as easily exist in the `hello.ts` file. Keeping it in a separate file like this however is a good idea if we are going to create large sites that run multiple Angular 2 apps for the user at the same time.


Now a common pattern I've seen in a lot of Angular 2 starter projects is to do something like the following in the bootstrap:

{% highlight ts %}
import 'es6-shim';
import 'reflect-metadata';
import 'zone.js';

import {bootstrap} from 'angular2/bootstrap';

import {HelloApp} from './hello';

bootstrap(HelloApp);
{% endhighlight %}

Now the idea behind this is to have Webpack build the polyfills for es6 and reflect-metadata as well as zone.js required by Angular 2 into your application bundle. The problem with this is these files are stand alone JavaScript modules designed to run as soon as they are imported from a `script` tag in your HTML. In particular zone.js needs to be run first before any other shims or polyfills or the resulting behaviour can be unpredictable. The `angular2-polyfills.js` file  include in the `index.html` is provided with the npm package of Angular 2 and provides both zone.js and reflect-metadata that are set up to load in the browser correctly.

You'll notice these polyfills are loaded from a `lib` directory that doesn't actually exist in the checked out code from the repository. This `lib` directory is created by the gulp tasks set up to build/run the app.

### Gulp Tasks

Again I'm assuming you have some familiarity with the [Gulp](http://gulpjs.com/) build system, personally I find this easier to work with than [Grunt](http://gruntjs.com/) and haven't tried many of the other build tools, but the same principals could probably be applied if you wanted to switch. I'm also not going to go through the whole file line by line as most of it is simple copy tasks, but lets take a look at the configured paths:

{% highlight javascript %}
var PATHS = {
  src: {
    ts: 'app/**/*.ts',
    html: ['!node_modules/**', '**/*.html'],
    css: ['!node_modules/**', '**/*.css']
  },
  shims: [
    'node_modules/angular2/bundles/angular2-polyfills.js',
    'node_modules/es6-shim/es6-shim.js'
  ],
  lib: [
    'lib/*.js'
  ],
  dist: 'dist'
};
{% endhighlight %}

hopefully everything in the above is self explanatory, you'll see the `PATH.shims` defines the location of the two JavaScript files needed in our `index.html` script tags and again makes reference to the `lib` directory that has yet to be created.  

The basic pipeline for building the app is as follows:

{: .post-num-list }
1. Perform a simple copy of everything matching the `PATHS.src.html` and `PATHS.src.css` patterns into the `dist` directory, preserving the folder structure.
2. Copy the `PATHS.shims` files into the `lib` directory in `ng2starter`
3. Use Webpack to build the app into `bundle.js` and place this in the `lib` directory. This build includes "uglyfying" the output file to help reduce file size.
4. Copy the `lib` directory and it's contents into `dist`

### Webpack

Webpack is a tool for creating static asset bundles out of multiple JavaScript (or derivatives) files that can be loaded in the browser as a single file. We use it here to take care of the transpilation of TypeScript to JavaScript as well as bundling this together with Angular 2, it's dependencies, and any other dependencies our app may need.

Lets have a look at the `webpack` gulp task:

{% highlight javascript %}
var webpack = require('webpack');
var webpackConfig = require('./webpack.config.js');

// snip

gulp.task('webpack', function(callback) {
  webpackConfig.plugins = [
    new webpack.optimize.UglifyJsPlugin({
      output: {
        comments: false
      }
    })
  ];
  // run webpack
  webpack(webpackConfig, function(err, stats) {
    if(err){
      throw new gutil.PluginError('webpack', err);
    }
    gutil.log('[webpack]', stats.toString({
      colors: true
    }));
    callback();
  });
});
{% endhighlight %}

This task simply loads in the `webpack.config.js` file and adds in the `UglifyJsPlugin` to the configured plugins, we do this here because the same configuration file is used by the Webpack development server and uglyfying the output for that step is unnecessary and makes debugging more difficult. The `webpack.config.js` file contains the following:

{% highlight javascript %}
var webpack = require('webpack');

module.exports = {
  entry: './app/bootstrap',
  output: {
    path: __dirname + '/lib', publicPath: 'lib/', filename: 'bundle.js'
  },
  resolve: {
    extensions: ['', '.js', '.ts']
  },
  module: {
    loaders: [{
      test: /\.ts/, loaders: ['ts-loader'], exclude: /node_modules/
    }]
  }
};
{% endhighlight %}

This again is a really simple configuration. We tell Webpack where the entry-point for our app is, in this case our `./app/bootstrap` module, and define an output path for our bundle `./lib/bundle.js`. We also configure the `ts-loader` module telling it to look for any files matching the `/\.ts/` regex and transpile them (this loader uses the `tsconfig.json` file for its configuration). What Webpack does when we call it though the Gulp command is scan our transpiled `bootstrap.ts` file looking for any module imports, it does this recursively until a complete dependency tree is built. These dependencies are then combined into the single bundle file we defined in the `output` arguments above.

The code in our `entry` module will be executed when this bundle is loaded into the browser through the `<script>` tag. As mentioned already this configuration file is used for both our build step and for the Webpack development server. As with build we have a Gulp task setup to run this server for us:

{% highlight javascript %}
var gulp = require('gulp');
var gutil = require('gulp-util');
var webpack = require('webpack');
var webpackDevServer = require('webpack-dev-server');
var webpackConfig = require('./webpack.config.js');

// snip

gulp.task('play', ['shims'], function(callback) {
  var compiler = webpack(webpackConfig);
  var open = require('open');

  new webpackDevServer(compiler, {
    publicPath: "/" + webpackConfig.output.publicPath,
    stats: {
      colors: true
    }
  }).listen(8080, "localhost", function(err) {
    if(err){
      throw new gutil.PluginError("webpack-dev-server", err);
    }
    // Server listening
    gutil.log("[webpack-dev-server]", "http://localhost:8080/index.html");
    open('http://localhost:8080/index.html');
  });
});
{% endhighlight %}

Webpack Development Server is based on the node.js [Express](http://expressjs.com/en/index.html) framework and allows us to serve our content in a simple test server what also watches files for changes and recompiles the bundles when necessary. The compilation process happens exactly as it does when we perform a full build, the only difference is that our `bundle.js` is compiled and served from in memory rather than being written to disk. All other static assets from our project are served using the directory structure of our project, this is why we keep that structure when Gulp copies our HTML, CSS, and shims to the `dist` directory.

### Other Gulp Tasks

There are two more Gulp tasks it's worth taking a look at the first is `serve-dist`. As the name implies this carries out a full build of the code and then opens up a simple static server to the files in the `dist` directory.

The second is the `ts-lint` task. Like other linters this tool scans our TypeScript code and reports back on any issues based on a set of rules in the `tslint.json` file. I've chosen defaults similar to those of the Angular2 team but these can be tweaked to your liking. A full set of the available options for the TsLint tool can be found [here](https://github.com/palantir/tslint#supported-rules).

### Why no tests?

You've probably noticed by now the lack of any tests in this setup. Angular 1.x, rightly, placed a lot of emphasis on being testable and Angular 2 will be too. The problem is as of the time of writing this still testing still isn't something easily done with Angular 2, or more accurately there are several ways the testing can be implemented, none of them particularly elegant. I have attempted to set up other projects with a Karma/Jasmine configuration but again there is no official method for doing this so for now I thought it best to leave it out of the simple starter.
